<!--
 * @Author       : zhaixiaowei@xdf.cn
 * @Date         : 2022-09-13 10:35:51
 * @LastEditors  : zhaixiaowei@xdf.cn
 * @LastEditTime : 2022-09-13 10:40:23
 * @Description  : 描述信息
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>策略模式2</title>
</head>
<body>
    <div>
        公司发放绩效的方式：s级别为工资的4倍，a为三倍，b为2倍，c为1倍
        实现一个算法。
    </div>
    <script>
        // 策略类定义为函数
        let strategies = {
            "S": function (salary) {
                return salary * 4
            },
            "A": function (salary) {
                return salary * 3
            },
            "B": function (salary) {
                return salary * 2
            },
            "C": function (salary) {
                return salary * 1
            },
        }
        // 环境类定义为函数
        const getBouns = (level, salary) => {
            return strategies[level](salary)
        }
        console.log(getBouns('S', 10000));

        /**
         * 策略模式的组成：
         * 1. 一组策略类，策略类封装了具体的算法，并负责具体的计算过程。
         * 2. 环境类，环境类接受客户的请求，随后把请求委托给一个策略类。
         * 
         * 再来看下策略模式的定义
            定义一系列的算法（这些算法目标一致），把它们一个个封装起来，并且使它们可以相互替换。
            算法：绩效的计算方法
            封装：计算方法被封装在策略对象内部，达到可复用
            相互替换：要更改某个绩效时，只要改变参数，不影响函数的调用
        **/
    </script>
</body>
</html>